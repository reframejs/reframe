Reframe, the web (anti-)framework &mdash; quickly implement an app, without lock-in.

!MENU
!MENU_ORDER 30

The customization manual acts as reference for customizing Reframe.
It gives a good overview of how parts can be re-written but partially lacks detailed information.
Open a GitHub issue to get detailed info and support.

# Customization Manual

##### Contents

 - [Custom Server](#custom-server)
   - [Reframe as hapi plugin](#reframe-as-hapi-plugin)
   - [Full Customization](#full-customization)
 - [Custom Browser JavaScript](#custom-browser-javascript)
   - [Custom Browser Entry](#custom-browser-entry)
   - [External Scripts](#external-scripts)
   - [Common Script](#common-script)
   - [Full Customization](#full-customization-1)
 - [Custom Build](#custom-build)
   - [Webpack Config Modification](#webpack-config-modification)
   - [Full Custom Webpack Config](#full-custom-webpack-config)
   - [Full Build Customization](#full-build-customization)
 - [Custom Repage](#custom-repage)
 - [Get rid of Reframe](#get-rid-of-reframe)

## Custom Server

##### Contents

 - [Reframe as hapi plugin](#reframe-as-hapi-plugin)
 - [Full Customization](#full-customization)

### Reframe as hapi plugin

Instead of using Reframe as CLI, we can use it as hapi plugins.
For example:

~~~js
!INLINE ../example/custom/server/hapi-server.js
~~~


### Full Customization

Instead of using `const {getReframeHapiPlugins} = require('@reframe/server');` we can also re-write the whole server part from scratch.

This allows us, for example, to choose any server framework.
The following is a custom server implementation using Express instead of hapi.

~~~js
!INLINE ../example/custom/server/express-server.js
~~~

## Custom Browser JavaScript

##### Contents

 - [Custom Browser Entry](#custom-browser-entry)
 - [External Scripts](#external-scripts)
 - [Common Script](#common-script)
 - [Full Customization](#full-customization-1)

### Custom Browser Entry

When Reframe stumbles upon a `.universal.js` or `.dom.js` page object, Reframe automatically generates a browser entry code that will be loaded in the browser.

The following is an example of such generated browser entry code.

~~~js
var hydratePage = require('/usr/lib/node_modules/@reframe/cli/node_modules/@reframe/browser/hydratePage.js');
var pageObject = require('/home/brillout/tmp/reframe-playground/pages/HelloPage.universal.js');

// hybrid cjs and ES6 modules import
pageObject = Object.keys(pageObject).length===1 && pageObject.default || pageObject;

hydratePage(pageObject);
~~~

We can, however, create the browser entry code ourselves.

Instead of providing a `.universal.js` or `.dom.js` page object, we provide only one page object `.html.js` along with a `.entry.js`.

For example:

~~~js
!INLINE ../example/pages/TrackingPage.html.js
~~~

~~~js
!INLINE ../example/pages/TrackingPage.entry.js
~~~

### External Scripts

The page's `<head>` is fully customaziable,
and we can load external scripts such as `<script async src='https://www.google-analytics.com/analytics.js'></script>`,
load a `<script>` as ES6 module,
add a `async` attribute to a `<script>`,
etc.

See the "Custom Head" section of the Usage Manual for more information.

### Common Script

Multiple pages can share common code by using the `diskPath` script object property as shown in the following example:

~~~js
!INLINE ../example/custom/browser/pages/terms.html.js
~~~
~~~js
!INLINE ../example/custom/browser/pages/privacy.html.js
~~~
~~~js
!INLINE ../example/custom/browser/pages/PageCommon.js
~~~
~~~js
!INLINE ../example/custom/browser/pages/PageCommon.entry.js
~~~

### Full Customization

We saw in the section "Custom Browser Entry" how to write the browser entry code ourself.

For example:

~~~js
import hydratePage from '@reframe/browser/hydratePage';
import MyPage from 'path/to/MyPage-page-object.js';

hydratePage(MyPage);
~~~

But we can go further by not using `@reframe/browser/hydratePage` and re-writing that part ouserlves.

Let's look at the code of `@reframe/browser/hydratePage`

~~~js
!INLINE ../browser/hydratePage.js
~~~

As we can see, the code simply initializes a Repage instance and calls `@repage/browser`'s `hydratePage()` function.

Instead of using Repage we could manually hydrate the page ourselves.
The following is an example of doing so.
At this point, our browser JavaScript doesn't depend on Reframe nor on Repage.
It is fully under our control.

~~~js
!INLINE ../example/custom/browser/pages/custom-browser.html.js
~~~
~~~js
!INLINE ../example/custom/browser/pages/custom-browser.entry.js
~~~

## Custom Build

##### Contents

 - [Webpack Config Modification](#webpack-config-modification)
 - [Full Custom Webpack Config](#full-custom-webpack-config)
 - [Full Build Customization](#full-build-customization)

### Webpack Config Modification

The webpack configuration generated by Reframe can be modified by providing
the arguments `getWebpackServerConfig` and `getWebpackBrowserConfig`
to `getReframeHapiPlugins()`.

~~~js
await getReframeHapiPlugins({
    pagesDir,
    getWebpackBrowserConfig,
    getWebpackServerConfig,
});
~~~

The following example uses `getWebpackBrowserConfig()` to add a PostCSS loader to the configuration.

~~~js
!INLINE ../example/custom/build/webpack-config-mod/config-mod.js
~~~
~~~js
!INLINE ../example/custom/build/webpack-config-mod/server.js
~~~

### Full Custom Webpack Config

The arguments
`getWebpackServerConfig` and `getWebpackBrowserConfig`
of `getReframeHapiPlugins()`,
mentioned in the previous section,
also allows us to use an entire custom webpack configuration.

The only restriction for a fully custom config is that the browser entry file and the corresponding server entry file have the same base name.
Reframe can't otherwise know which browser entry is meant for wich page object.
For example, a browser entry saved at `/path/to/MyPage.entry.js` would match a page object saved at `/path/to/MyPage.html.js`, because they share the same base name `MyPage`.

The following is a `getWebpackBrowserConfig()` usage example for a entirely custom config.

~~~js
!INLINE ../example/custom/build/custom-webpack-config/webpack-config.js
~~~
~~~js
!INLINE ../example/custom/build/custom-webpack-config/server.js
~~~

### Full Build Customization

By default, Reframe uses webpack.
But we can implement a fully custom build step, which means that we can use a build tool other than webpack.

The following is an example of a custom build step using [Rollup](https://github.com/rollup/rollup) and [Node.js's support for ES modules over the --experimental-modules flag](https://nodejs.org/api/esm.html).

~~~js
!INLINE ../example/custom/build/custom-bundler/server.mjs
~~~
~~~js
!INLINE ../example/custom/build/custom-bundler/build-all.mjs
~~~
~~~js
!INLINE ../example/custom/build/custom-bundler/build-script.mjs
~~~
~~~js
!INLINE ../example/custom/build/custom-bundler/build-html.mjs
~~~
~~~js
!INLINE ../example/custom/build/custom-bundler/get-pages.mjs
~~~

## Custom Repage

Reframe is built on top of [Repage](https://github.com/brillout/repage),
a low-level plugin-based page management library,
and you can use Reframe with a custom Repage instance.

To do so,
and as shown in the example bellow,
we export a `getRepageInstance` function
that returns the Repage instance we want to use
in a `reframe.config.js` file.

The `reframe.config.js` file can be located at any ancestor directory of the `pages/` directory.

~~~js
const Repage = require('@repage/core');
const RepageRouterCrossroads = require('@repage/router-crossroads');
const RepageRenderer = require('@repage/renderer');
const RepageRendererReact = require('@repage/renderer-react');

module.exports = {getRepageInstance};

function getRepageInstance() {
    const repage = new Repage();

    repage.addPlugins([
        RepageRouterCrossroads,
        RepageRenderer,
        RepageRendererReact,
    ]);

    return repage;
}
~~~

## Get rid of Reframe

As show in this document, every part of Reframe can be re-written to depend on `@repage` packages only.
In turn, [Repage](https://github.com/brillout/repage) can progressively be overwritten over time as well.
This means that we can eventually and over time get rid of the entire Reframe and Repage code.
